set(SINGLEAPPLICATION_VERSION_MAJOR 3)
set(SINGLEAPPLICATION_VERSION_MINOR 0)
set(SINGLEAPPLICATION_VERSION_PATCH 13)
#set(SINGLEAPPLICATION_VERSION_PRERELEASE rc1)

set(INCLUDE_GIT_REVISION ON)

# 1. If the library source code has changed at all since the last update, then increment revision.
# 2. If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.
# 3. If any interfaces have been added since the last public release, then increment age.
# 4. If any interfaces have been removed since the last public release, then set age to 0.
set(SINGLEAPPLICATION_SOVERSION_CURRENT  0)
set(SINGLEAPPLICATION_SOVERSION_REVISION 0)
set(SINGLEAPPLICATION_SOVERSION_AGE      0)


set(majorminorpatch "${SINGLEAPPLICATION_VERSION_MAJOR}.${SINGLEAPPLICATION_VERSION_MINOR}.${SINGLEAPPLICATION_VERSION_PATCH}")

set(SINGLEAPPLICATION_VERSION_DISPLAY "${majorminorpatch}")
set(SINGLEAPPLICATION_VERSION_PACKAGE "${majorminorpatch}")

if(${SINGLEAPPLICATION_VERSION_PATCH} EQUAL "0")
  set(SINGLEAPPLICATION_VERSION_DISPLAY "${SINGLEAPPLICATION_VERSION_MAJOR}.${SINGLEAPPLICATION_VERSION_MINOR}")
endif(${SINGLEAPPLICATION_VERSION_PATCH} EQUAL "0")

if(SINGLEAPPLICATION_VERSION_PRERELEASE)
  set(SINGLEAPPLICATION_VERSION_DISPLAY "${SINGLEAPPLICATION_VERSION_DISPLAY} ${SINGLEAPPLICATION_VERSION_PRERELEASE}")
  set(SINGLEAPPLICATION_VERSION_RPM_R   "0.${SINGLEAPPLICATION_VERSION_PRERELEASE}")
  set(SINGLEAPPLICATION_VERSION_PACKAGE "${SINGLEAPPLICATION_VERSION_PACKAGE}${SINGLEAPPLICATION_VERSION_PRERELEASE}")
endif(SINGLEAPPLICATION_VERSION_PRERELEASE)

math(EXPR SINGLEAPPLICATION_SOVERSION_MAJOR "${SINGLEAPPLICATION_SOVERSION_CURRENT} - ${SINGLEAPPLICATION_SOVERSION_AGE}")
math(EXPR SINGLEAPPLICATION_SOVERSION_MINOR "${SINGLEAPPLICATION_SOVERSION_AGE}")
math(EXPR SINGLEAPPLICATION_SOVERSION_PATCH "${SINGLEAPPLICATION_SOVERSION_REVISION}")

if(INCLUDE_GIT_REVISION AND EXISTS "${CMAKE_SOURCE_DIR}/.git")

  find_program(GIT_EXECUTABLE git)
  if(NOT GIT_EXECUTABLE OR GIT_EXECUTABLE-NOTFOUND)
    message(FATAL_ERROR "Missing GIT executable." )
  endif()

  # Get the current working branch
  execute_process(
    COMMAND ${GIT_EXECUTABLE} rev-parse --abbrev-ref HEAD
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    RESULT_VARIABLE GIT_CMD_RESULT_BRANCH
    OUTPUT_VARIABLE GIT_BRANCH
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
  )
  # Get the latest abbreviated commit hash of the working branch
  execute_process(
    COMMAND ${GIT_EXECUTABLE} describe --long --tags --always
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    RESULT_VARIABLE GIT_CMD_RESULT_REVISION
    OUTPUT_VARIABLE GIT_REVISION
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
  )

  if(NOT ${GIT_CMD_RESULT_REVISION} EQUAL 0)
    message(FATAL_ERROR "GIT command failed to get revision string '${GIT_REVISION}'")
  endif()

endif()

if(FORCE_GIT_REVISION)
  set(GIT_REVISION ${FORCE_GIT_REVISION})
endif()

if(GIT_REVISION)

  string(REGEX REPLACE "^(.+)-([0-9]+)-(g[a-f0-9]+)$" "\\1;\\2;\\3" GIT_PARTS ${GIT_REVISION})

  if(NOT GIT_PARTS)
    message(FATAL_ERROR "Failed to parse git revision string '${GIT_REVISION}'")
  endif()

  list(LENGTH GIT_PARTS GIT_PARTS_LENGTH)
  if(NOT GIT_PARTS_LENGTH EQUAL 3)
    message(FATAL_ERROR "Failed to parse git revision string '${GIT_REVISION}'")
  endif()

  list(GET GIT_PARTS 0 GIT_TAGNAME)
  list(GET GIT_PARTS 1 GIT_COMMITCOUNT)
  list(GET GIT_PARTS 2 GIT_SHA1)

  set(HAS_GIT_REVISION ON)

  set(SINGLEAPPLICATION_VERSION_DISPLAY "${GIT_REVISION}")
  set(SINGLEAPPLICATION_VERSION_PACKAGE "${GIT_TAGNAME}.${GIT_COMMITCOUNT}.${GIT_SHA1}")

endif()
